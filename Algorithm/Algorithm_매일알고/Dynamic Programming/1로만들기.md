## 1로 만들기
백준
실버3
<br>
---
*사족*
- *자두나무를 풀고싶었는데 DP 개념이 와닿지 않아서 실버 단계 문제를 찾음*
- *처음엔 이해가 안되어서 재귀로 풀고 틀림*
- *"점화식"이라고도 하는데 값을 업데이트 하고 그걸 사용하는 방식을 이해하면 됨*

---
#### 문제
세 가지의 연산이 가능하다. 입력받은 숫자 N을 1로 만들기 위한 최소 연산 횟수를 구해라
<br>
세 가지 연산 = -1, %2, %3

#### 접근
- 연산을 1부터 한다고 생각하고 +1, *2, *3을 사용
- 1~N 1차원 배열을 만들어서 각 인덱스 숫자를 만들기위한 최소 연산값을 저장
- 마지막에 배열의 N번째 인덱스 값을 리턴

#### 코드
```python
N = int(input())
arr = [N+1]*(N+1)
arr[1] = 0

def update(i, idx):
    if i <= N:
        if arr[i] != (N+1):
            arr[i] = min(arr[i], arr[idx] + 1)
        else:
            arr[i] = arr[idx] + 1
# 1~N만큼 반복하면서 해당 숫자를 만들 수 있는 최소 횟수를 저장
for i in range(1, N):
    for x in (i+1, i*2, i*3):
        update(x, i)

print(arr[N])
```
- 3가지 연산에 대해 값을 확인하고, 배열을 갱신하는 update함수를 만듦
- 연산값 인덱스의 배열 값이 이미 있으면 현재 숫자에서 연산해서 만드는 횟수와 비교 
- 배열 값이 없으면 현재 인덱스 자리의 값(연산횟수)에 1을 더해서 갱신
- 최종적으로 N자리에는 N을 만들기위한 최소 연산횟수가 들어감
