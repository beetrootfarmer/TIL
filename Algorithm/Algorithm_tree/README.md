# 트리 🌳

## 트리

- 비선형구조
- 원소들 간에 1:n 관계를 가지는 자료구조
- 원소들간 계층관계를 가지는 계층형 자료구조
- 상위원소에서 하위 원소로 내려가면서 확장되는 트리~나무모양

### 트리 용어

- 최상위노드 = 루트(root)
- 단말노드 = 잎(leaf)노드
    
    ![스크린샷 2022-09-13 오후 5.18.31.png](%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20%F0%9F%8C%B3%201369a08888e341b584af85fd6b0ad821/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-09-13_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.18.31.png)
    
- 노드(node) : 트리의 원소
- 간선(edge) : 노드를 연결하는 선
- 형제노드 : 같은 부모의 자식노드
- 조상노드 : 간선을 따라 루트까지 있는 모든 노드
- 서브트리(부트리) : 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
- 자손노드 : 서브트리에 있는 하위 노드
- 차수(degree)
    - 노드의 차수 : 자식 노드의 수
    - 트리의 차수 : 트리노드 차수 중 가장 큰 값
    - 단말 노드 : 차수가 0인 노드
- 높이
    - 노드의 높이 : 루트에서 노드에 이르는 간선의 수
    - 트리의 높이 : 트리에 있는 노드의 높이중 가장 큰 값

---

## 이진트리

- 모든 노드들이 최대 2개의 서브트리를 갖는 형태의 트리
- 높이가 h인 이진트리가 가질 수 있는 노드의 개수는
    
    $$
    최소 h+1 , 최대 2^{h+1} -1
    $$
    

### 포화 이진트리(Full Binary Tree)

- 높이가 h일 때 $(2^{h+1}-1)$의 노드를 가진 이진트리

### 완전 이진트리(Complete Binary Tree)

- 높이가 h이고 노드 수가 n개일 때 1~n번 노드에 빈자리가 없는 이진트리

### 편향 이진트리(Skewed Binary Tree)

- 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진트리

---

## 이진트리 순회(traversal)

노드를 중복되지 않게 전부 방문하는 것 

V : 현재 노드 n , L : n의 왼쪽 서브트리 , R : n의 오른쪽 서브트리

### 전위순회(preorder traversal) : VLR

![스크린샷 2022-09-13 오후 5.40.28.png](%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20%F0%9F%8C%B3%201369a08888e341b584af85fd6b0ad821/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-09-13_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.40.28.png)

### 중위순회(inorder traversal) : LVR

![스크린샷 2022-09-13 오후 5.40.56.png](%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20%F0%9F%8C%B3%201369a08888e341b584af85fd6b0ad821/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-09-13_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.40.56.png)

### 후위순회(postorder traversal) : LRV

![스크린샷 2022-09-13 오후 5.41.12.png](%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20%F0%9F%8C%B3%201369a08888e341b584af85fd6b0ad821/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-09-13_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.41.12.png)

---

## 배열로 이진트리 표현

- 이진트리의 노드 번호의 성질
    - 노드번호가 i인 노드의
        
        부모노드 번호는 $i/2$
        왼쪽자식 노드번호는 $2*i$
        오른쪽자식 노드번호는 $2*i + 1$
        
    - 레벨 n의 노드 시작번호는 $2^n$
- 배열을 이용한 이진트리의 단점
    - 편향 이진트리의 경우 메모리 공간낭비발생
    - 트리 중간에 새로운 노드를 삽입하거나 삭제할 경우 크기변경이 어려움

## 연결리스트로 이진트리 표현

- 배열을 이용한 이진트리의 단점을 보완하기 위한 표현방법
- 이진트리는 최대 2개의 자식노드를 가지기 때문에 단순 연결리스트로 표현가능
- 데이터 왼쪽이 왼쪽자식노드, 오른쪽에 오른쪽 자식노드 위치

---

## 수식트리

- 수식을 표현하는 트리로 수식 이진트리(Expression Binary Tree)라 부르기도 함
- 피연산자는 모두 잎 노드
- 중위순회 할 경우 중위표기법, 후위순회 할 경우 후위표기법

---

## 이진 탐색 트리

- 탐색작업을 효율적으로 하기 위한 자료구조
- 모든 원소는 서로 다른 유일한 키를 가짐
- 값의 크기는 왼쪽 서브트리의 key < 루트노드의 key < 오른쪽 서브트리의 key
- 중위순회하면 오름차순으로 정렬된 값을 얻을 수 있다

### 탐색연산

1. 루트에서 시작해 키 값과 노드의 값을 비교 
2. 키값이 더 작을 경우 왼쪽 서브트리 탐색연산 수행
3. 키값이 더 클 경우 오른쪽 서브트리 탐색연산 수행 

### 삽입연산

1. 탐색연산을 수행하여 같은 원소가 있느지 탐색
2. 탐색을 실패한 지점에 원소를 삽입

### 이진트리의 성능

- 탐색, 삽입, 삭제의 시간은 트리의 높이만큼 소요 $O(h)$
- 균형적으로 생성되어있는 이진트리는 $O(log n)$
- 최악의 경우= 경사 이진트리의 경우 순차탐색과 시간복잡도가 같음 $O(n)$

---

## 힙(heap)

### 최대 힙 max heap

- 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리
- 부모노드의 키값 > 자식노드의 키값
- 루트 노드 : 키값이 가장 큰 노드

### 최소 힙 min heap

- 키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리
- 부모노드의 키값 < 자식노드의 키값
- 루트 노드 : 키값이 가장 작은 노드

---

### 내가 가진 리스트를 최소힙으로 바꾸는 과정

```python
N = 6
data = [3, 6, 9, 1, 8, 2]

# tree = 리스트로 표현
# 0번 인덱스는 사용하지 않는다
tree = [0 for _ in range(N+1)]
last = 1
for i in range(len(data)):
    if not tree[i]:
        tree[last] = data[i]
    else:
        last += 1
        child = last
        parent = child // 2

        tree[child] = data[i]

        while parent and tree[parent] > tree[child]:
            tree[parent], tree[child] = tree[child] , tree[parent]
            child = parent
            parent = child // 2 # parent = parent//2

print(tree)
```