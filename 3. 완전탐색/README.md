# 완전탐색

# 1. 부분집합

## 배열의 합

```python
def f(i, k):
    global minV
    if i == k:
        s = 0
        for l in range(k):
            s += arr[l][p[l]]
        if minV > s:
            minV = s
    else:
        for j in range(i, k):
            p[i],p[j] = p[j], p[i]
            f(i+1, k)
            p[i],p[j] = p[j], p[i]

T = int(input())
for tc in range(1, T+1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
    p = [i for i in range(N)]
    minV = N*10
    f(0, N)
    print(f'#{tc} {minV}')
```

## 부분집합

- 집합에 포함된 원소들을 선택하는 것
- 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분 집합을 찾는 것
- N 개의 원소를 포함한 집합
    - 자기자신과 공집합을 포함한 모든 부분집합(power set)의 개수는 2^n개(포함/미포함)
    - 원소의 수가 증가하면 부분집합의 개수는 지수적으로 증가

### 바이너리 카운팅을 통한 사전적 순서(Lexicorgraph Order)

바이너리 카운팅(Binary Counting)

- 원소 수에 해당하는 N개의 비트열을 이용
- n번째 비트값이 1이면 n번째 원소가 포함되었음을 의미함
- for i in range(1<<n):

![스크린샷 2022-10-02 오후 8.53.36.png](%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%2067ab9e60606b4079a5e8cfda82283197/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.53.36.png)

- 비트 연산자로 바이너리 카운팅

```python
arr = [3, 6, 7, 1, 5, 4]
n = len(arr)

for i in range(0, (1<<n)):
	for j in range(0, n):
		if  i & (1<<j):
			print(arr[j], end= ' ')
	print()
```

- 실행결과
    
    ```python
    # 실행 결과
    3 
    6 
    3 6 
    7 
    3 7 
    6 7 
    3 6 7 
    1 
    3 1 
    6 1 
    3 6 1 
    7 1 
    3 7 1 
    6 7 1 
    3 6 7 1 
    5 
    3 5 
    6 5 
    3 6 5 
    7 5 
    3 7 5 
    6 7 5 
    3 6 7 5 
    1 5 
    3 1 5 
    6 1 5 
    3 6 1 5 
    7 1 5 
    3 7 1 5 
    6 7 1 5 
    3 6 7 1 5 
    4 
    3 4 
    6 4 
    3 6 4 
    7 4 
    3 7 4 
    6 7 4 
    3 6 7 4 
    1 4 
    3 1 4 
    6 1 4 
    3 6 1 4 
    7 1 4 
    3 7 1 4 
    6 7 1 4 
    3 6 7 1 4 
    5 4 
    3 5 4 
    6 5 4 
    3 6 5 4 
    7 5 4 
    3 7 5 4 
    6 7 5 4 
    3 6 7 5 4 
    1 5 4 
    3 1 5 4 
    6 1 5 4 
    3 6 1 5 4 
    7 1 5 4 
    3 7 1 5 4 
    6 7 1 5 4 
    3 6 7 1 5 4
    ```
    

- 재귀로 바이너리 카운팅

```python
def f(i, k):
	if i == k:
		for j in range(k):
			if bit[j]:
				print(arr[j], end = ' ')
		print()
	else:
		bit[i] = 0
		f(i+1, k)
		bit[i] = 1
		f(i+1, k)
arr = [3, 6, 7]
n = len(arr)

bit = [0] * n
f(0, n)
```

- 실행결과
    
    ```python
    
    7 
    6 
    6 7 
    3 
    3 7 
    3 6 
    3 6 7
    ```
    

---

# 2. 순열

## Permutation

- 서로 다른 것들 중 몇개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열
    
    $$
    \mathrm{ _nP_r}
    $$
    
- nPr식을 풀어쓰기
    
    $$
    _nP_r = n * (n-1) * (n-2) *...*(n-r+1)
    $$
    
- nPn = n! 이라고 표기하며 Factorial이라 부른다
    
    $$
    n! = n *(n-1) * (n-2) *...*2 * 1
    $$
    
- 다수의 알고리즘 문제들은 순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련이 있다
    - 예) TSP(Traveling Salesman Problem)
- N개의 요소들에 대해서 n!개의 순열들이 존재한다
    - 12! = 479001600
    - n> 12인 경우 시간복잡도가 폭팔적으로 증가한다..

### 순열 생성방법

- 사전적 순서(Lexicographic-Order)
    - {1, 2, 3}, n = 3인 경우
    - [1 2 3 ] [1 3 2] [2 1 3] [2 3 1] [3 1 2] [3 2 1]
- 최소 변경을 통한 방법(Minimum-exchange requirement)
    - 각각의 순열들은 이전의 상태에서 단지 두 개의 요소들 교환을 통해 생성
    - [1 2 3 ] [3 2 1] [2 3 1] [2 1 3] [3 1 2] [1 3 2]
    
- 재귀를 이용한 순열 생성

```python
def f(i, k):
    if i == k:
        print(p)
    else:
        for j in range(i, k):
            p[i], p[j] = p[j], p[i]
            f(i+1, k)
            p[i], p[j] = p[j], p[i]
p = [1, 2, 3]
f(0, 3)
```

![변경 이전으로 돌아간다는 것 ](%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%2067ab9e60606b4079a5e8cfda82283197/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.25.27.png)

변경 이전으로 돌아간다는 것 

- 실행결과
    
    ```python
    [1, 2, 3]
    [1, 3, 2]
    [2, 1, 3]
    [2, 3, 1]
    [3, 2, 1]
    [3, 1, 2]
    ```
    

- used(visited[])를 활용한 순열생성

```python
def f(i, k):
    if i == k:
        print(p)
    else:
        for j in range(k):
            if used[j] == 0:
                used[j] = 1
                p[i] = a[j]
                f(i+1, k)
                used[j] = 0

N = 3
a = [i for i in range(1, N+1)]
used = [0] *N
p = [0] * N
f(0, 3)
```

![스크린샷 2022-10-02 오후 9.29.06.png](%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%2067ab9e60606b4079a5e8cfda82283197/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.29.06.png)

- 실행결과
    
    ```python
    [1, 2, 3]
    [1, 3, 2]
    [2, 1, 3]
    [2, 3, 1]
    [3, 1, 2]
    [3, 2, 1]
    ```
    

---

# 3. 조합

### Combination

- 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것
- 조합의 수식
    
    $$
    _nC_r = {n!\over (n-r)!r!}, (n >= r)
    $$
    
    $$
    _nC_r = _{n-1}C_{r-1}+_{n-1}C_r
    $$
    
    → n개에서 r개를 고르는 경우는 n-1개에서 r-1개를 고르는 경우와 n-1개에서 r개를 고를 경우의 수를 합 한것과 같다
    
    $$
    _nC_0 = 1
    $$
    
- for 문으로 10개의 원소 중 3개를 고르는 조합
    
    → 두개의 구간으로 나눔
    
    ```python
    for i in range(N-2):      # 0~7
    	for j in range(i+1, N-1):  # 1~8
    		for k in range(j+1, N):  # 2~9
    			f(a[i], a[j], a[k])
    
    ```
    

- 재귀를 사용한 조합
    
    ```python
    def nCr(n, r, s):
        if r == 0:
            print(*comb)
        else:
            for i in range(s, **n-r+1**):
                comb[r-1] = A[i]
                nCr(n, r-1, i+1)
    A = list(range(1, 6))
    n = len(A)
    r = 3
    comb = [0] * r
    nCr(n, r, 0)
    ```
    
    - 실행결과
        
        ```python
        3 2 1
        4 2 1
        5 2 1
        4 3 1
        5 3 1
        5 4 1
        4 3 2
        5 3 2
        5 4 2
        5 4 3
        ```
        
    

### 연습문제

- 부분집합의 합 문제
    - 10개의 정수 집합에 대한 모든 부분집합 중 원소의 합이 0이 되는 집합을 모두 출력하시오
        
        {-1, 3, -9, 6, 7, -6, 1, 5, 4, -2}
        
    
    → 모든 경우를 고려해야한다면 바이너리카운팅이 낫지 않을까?
    

- 재귀를 사용한 코드

```python
def f(i, k):
    if i == k:
        s = []
        for j in range(k):
            if bit[j]:
                s.append(arr[j])
        if sum(s) == 0:
            print(*s)
    else:
        bit[i] = 0
        f(i+1, k)
        bit[i] = 1
        f(i+1, k)

arr = [-1, 3, -9, 6, 7, -6, 1, 5, 4, -2]
n = len(arr)
bit = [0] * n
f(0, n)
```

- 비트연산자를 사용한 코드

```python
def b(n):
    for i in range(0, (1<<n)):
        s = []
        for j in range(0, n):
            if  i & (1<<j):
                s.append(arr[j])
        if sum(s) == 0:
            print(s)

arr = [-1, 3, -9, 6, 7, -6, 1, 5, 4, -2]
n = len(arr)
bit = [0] * n
# f(0, n)
b(n)
```